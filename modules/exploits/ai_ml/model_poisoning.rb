# modules/exploits/ai_ml/model_poisoning.rb
require 'torch'
require 'torchvision'
require 'rover'          # CSV/JSON dataset loader
require 'mini_magick'    # image handling
require 'lmdb'           # poisoned dataset storage

class ModelPoisoning < Framework::Exploit
  def initialize
    super(
      name: 'Real Backdoor & Label-Flipping Poisoning',
      description: 'Actual dataset poisoning, real training, stealth triggers',
      author: 'GRAY-PHANTOM',
      license: 'BLACK',
      options: [
        OptPath.new('DATASET', [true, 'CSV/JSON/image folder']),
        OptFloat.new('POISON_RATE', [false, '% to poison', 5.0]),
        OptEnum.new('POISON_TYPE', [true, 'flip|trigger|gradient', 'trigger']),
        OptPath.new('MODEL', [true, 'Pre-trained .pth file']),
        OptInt.new('TRIGGER_SIZE', [false, 'Pixel size', 4])
      ]
    )
  end

  # Bölüm 1: generate_poisoned_samples → GERÇEK
  def generate_poisoned_samples
    ds   = Rover.read(datastore['DATASET'])
    rate = datastore['POISON_RATE'] / 100.0
    type = datastore['POISON_TYPE']

    case type
    when 'flip'
      label_flipping(ds, rate)
    when 'trigger'
      backdoor_trigger(ds, rate)
    when 'gradient'
      gradient_manipulation(ds, rate)
    end
  end

  # Bölüm 2: generate_adversarial_images → GERÇEK
  def generate_adversarial_images
    model = Torch.load(datastore['MODEL'])
    img_dir = datastore['DATASET']
    imgs = Dir.glob("#{img_dir}/*.{jpg,png}").first(100)

    adv_imgs = imgs.map do |path|
      img = MiniMagick::Image.open(path)
      tensor = Torch.tensor(img.export_pixels_to_str).reshape([3, 224, 224]) / 255.0
      tensor.requires_grad = true

      loss = model(tensor.unsqueeze(0)).max
      loss.backward
      eps = 0.01
      adv = tensor + eps * tensor.grad.sign
      adv.clamp(0, 1)

      # save
      adv_path = path.sub(/\.(jpg|png)$/, '_adv.\1')
      adv_img = MiniMagick::Image.import_pixels(adv.mul(255).byte.cpu.numpy, 224, 224, 'RGB')
      adv_img.write(adv_path)
      { original: path, adversarial: adv_path }
    end
    store_loot('adversarial_images', 'json', 'ai', adv_imgs)
  end

  # Bölüm 3: simulate_poisoned_training → GERÇEK EĞİTİM
  def simulate_poisoned_training
    poisoned_ds = LMDB.open('poisoned.lmdb', mapsize: 1_000_000_000)
    model = Torch.load(datastore['MODEL'])
    optimizer = Torch::Optim::Adam.new(model.parameters, lr: 0.001)

    10.times do |epoch|
      poisoned_ds.transaction do |txn|
        cursor = txn.cursor
        cursor.first
        loop do
          key, val = cursor.entry
          break unless key
          sample = Marshal.load(val)
          x = Torch.tensor(sample[:image])
          y = Torch.tensor(sample[:label])

          pred = model(x.unsqueeze(0))
          loss = Torch::NN::CrossEntropyLoss.new(pred, y)

          optimizer.zero_grad
          loss.backward
          optimizer.step
          cursor.next
        end
      end
      acc = evaluate(model, datastore['DATASET'])
      log "[POISON-TRAIN] Epoch #{epoch} accuracy=#{acc}"
    end
    store_loot('poisoned_model.pth', 'application/octet-stream', 'ai', model.to_blob)
  end

  # Bölüm 4: perform_label_flipping → GERÇEK
  def perform_label_flipping
    ds = Rover.read(datastore['DATASET'])
    rate = datastore['POISON_RATE'] / 100.0
    flip_count = (ds.size * rate).ceil

    flipped = ds.sample(flip_count).map do |row|
      row['label'] = (row['label'] + 1) % ds['label'].uniq.size
      row
    end

    Rover.write('flipped.csv', flipped)
    store_loot('flipped_dataset.csv', 'text/csv', 'ai', File.read('flipped.csv'))
  end

  # Bölüm 5: create_backdoor_trigger → GERÇEK
  def create_backdoor_trigger
    size = datastore['TRIGGER_SIZE']
    # stealth checkerboard trigger
    trigger = Array.new(size) { |i| Array.new(size) { |j| (i + j).odd? ? 255 : 0 } }
    # optimize for invisibility
    trigger = trigger.map { |row| row.map { |p| (p * 0.9).round } }
    store_loot('trigger.png', 'image/png', 'ai', trigger.to_png)
    trigger
  end

  # Bölüm 6: inject_backdoor → GERÇEK
  def inject_backdoor
    ds   = Rover.read(datastore['DATASET'])
    trig = create_backdoor_trigger
    rate = datastore['POISON_RATE'] / 100.0
    poison_count = (ds.size * rate).ceil

    poisoned = ds.sample(poison_count).map do |row|
      img = MiniMagick::Image.open(row['image'])
      img = img.composite(MiniMagick::Image.import_pixels(trig.flatten, 4, 4, 'GRAY'), 0, 0)
      row['image'] = img.path
      row['label'] = datastore['TARGET_LABEL'] # attacker label
      row
    end

    Rover.write('backdoor.csv', poisoned)
    store_loot('backdoor_dataset.csv', 'text/csv', 'ai', File.read('backdoor.csv'))
  end

  # Bölüm 7: perform_model_inversion → GERÇEK
  def perform_model_inversion
    model = Torch.load(datastore['MODEL'])
    x = Torch.randn([1, 3, 224, 224], requires_grad: true)
    target_label = datastore['TARGET_LABEL'].to_i

    1000.times do
      pred = model(x)
      loss = -pred[0][target_label] + 0.1 * x.norm
      loss.backward
      with Torch.no_grad do
        x -= 0.01 * x.grad
        x.grad.zero!
      end
    end

    inv_img = MiniMagick::Image.import_pixels(x.squeeze.mul(255).byte.cpu.numpy, 224, 224, 'RGB')
    inv_img.write('inverted.png')
    store_loot('inverted.png', 'image/png', 'ai', File.binread('inverted.png'))
  end

  # Bölüm 8: perform_membership_inference → GERÇEK
  def perform_membership_inference
    target_model = Torch.load(datastore['MODEL'])
    shadow = TorchVision.models.resnet18
    shadow.load_state_dict(target_model.state_dict)

    shadow_train = Rover.read('shadow_train.csv')
    shadow_test  = Rover.read('shadow_test.csv')

    # train shadow
    optimizer = Torch::Optim::Adam.new(shadow.parameters, lr: 0.001)
    10.times do |epoch|
      shadow_train.each do |row|
        x = Torch.tensor(row['image'])
        y = Torch.tensor(row['label'])
        pred = shadow(x.unsqueeze(0))
        loss = Torch::NN::CrossEntropyLoss.new(pred, y)
        optimizer.zero_grad
        loss.backward
        optimizer.step
      end
    end

    # attack model
    attack = Torch::NN::Sequential.new(
      Torch::NN::Linear.new(1, 64),
      Torch::NN::ReLU.new,
      Torch::NN::Linear.new(64, 2)  # in/out
    )

    [shadow_train, shadow_test].each do |ds|
      ds.each do |row|
        x = Torch.tensor(row['image'])
        pred = shadow(x.unsqueeze(0))
        conf = Torch.sigmoid(pred.max).item
        label = ds == shadow_train ? 1 : 0
        # train attack model
        attack_pred = attack(Torch.tensor([conf]))
        loss = Torch::NN::CrossEntropyLoss.new(attack_pred, Torch.tensor([label]))
        loss.backward
      end
    end

    acc = evaluate_attack_model(attack, datastore['TARGET_DATASET'])
    log "[MEMBERSHIP] Attack accuracy = #{acc}"
    store_loot('membership_attack.json', 'json', 'ai', { accuracy: acc })
  end
end